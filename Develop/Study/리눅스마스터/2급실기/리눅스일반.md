# 리눅스 마스터 : PART01 리눅스 일반

- 2급 실기

- 참고자료 : 이기적 기본서 리눅스마스터 2급 (권소라 저)

## CHAPTER01. 리눅스의 이해

<hr>

### 리눅스의 개요

✔ 리눅스의 특징

1. 리눅스는 오픈 소스 운영체제이다.
2. 다중 스레드를 지원하는 네트워크 운영체제이다.
3. 여러 종류의 파일 시스템을 지원하는 운영체제이다.
4. 리눅스는 유닉스와 완벽하게 호환 가능하다.
5. 리눅스는 POSIX 규격을 따르고 있다.

✔ 리눅스 디렉토리 종류와 특징

```
/ : 최상위 디렉토리

/proc : 가상 파일 시스템

/lib : 동적 공유 라이브러리 저장

/dev : 하드디스크, 프린터, 입출력 장치 등과 같은 장치들을 파일화하여 관리

/etc : 시스템 환경 설정 파일과 부팅 관련 스크립트 파일들이 저장되어 있는 디렉토리

/usr : 시스템이 아닌 일반 사용자들이 사용하는 디렉토리, 공유 가능한 프로그램들이 설치되며 네트워크를 이용해서 여러 개의 시스템을 연결 할 경우 이 디렉토리를 공유해서 설치된 프로그램들을 활용할 수 있다. (/usr 디렉토리는 읽기 전용으로 마운트 되어야 하며, 가변 자료들은 /var 디렉토리로 심볼릭 링크로 사용하게 된다.)

/var : 시스템에서 사용되는 가변적인 파일(로그파일, 스풀링, 캐싱 등)들을 저장하는 디렉토리

/lost+found : 파일시스템의 이상 유무를 진단하고 복구하는 fsck에 의해서 사용되는 디렉토리
```

✔ 리눅스 배포판

리눅스 배포판은 리눅스 전체 시스템을 구성하는 소프트웨어 패키지 형태로 대표적인 배포판은 슬랙위어, 데비안, 레드햇 등이 있다.

- 페도라, 레드햇, openSUSE, 노벨, 우분투는 캐노니컬 등의 기업이 관리하는 배포판

- 데비안, 젠투는 리눅스 커뮤니티 기반의 배포판

✔ 리눅스 배포판 종류

1. 슬랙웨어 리눅스 : 가장 먼저 대중화된 배포판, 구조가 간결하고 파악하기 쉬워 유닉스 학습에 리눅스를 사용하고 싶어하는 사용자들에게 적합

2. 데비안 : 데비안 프로젝트에서 만들어 배포하는 공개 운영체재로 GNU의 공식적인 후원을 받고 있는 유일한 배포판

3. 우분투 : 데비안 GNU/리눅스에 기초한 운영체제, 고유한 데스크탑 환경인 유니티를 사용하는 리눅스 배포판이다. 6개월 마다 새 버전이 하나씩 배포, 사용자 편의성에 초점을 맞추고 있다.

4. 레드햇 : 미국의 레드햇사가 개발하던 리눅스 배포판으로 현재는 레드햇사가 유료로 기술지원을 하는 기업용 레드햇 엔터프라이즈 리눅스(RHEL)와 페도라 프로젝트에서 개발하고 있는 페도라로 나뉘어 있다. 레드햇은 기업용 유료 리눅스의 배포판인 RHEL의 개발을 지원한다.

5. RHEL : 레드햇이 개발하여 판매하고 있는 상용 리눅스 배포판이다. 
- 18~24개월에 한 번씩 새로운 버전이 공개되며 라이선스는 별도로 판매하지 않는다.
- 서브 스크립션의 형태로 요금을 지불하는 방식으로 계약한다.
- 기술 지원은 버전마다 출시 시점으로부터 7년 동안 제공한다.
- 계약기간 중에는 추가 비용 없이 업그레이드 및 다운그레이드를 자유롭게 실시할 수 있다.

6. 페도라 
- 리눅스 커널에 기반한 운영체제와 레드햇의 후원과 개발 공동체 지원 아래 개발된 배포판으로 6개월 간격으로 새로운 버전이 배포되며 지원기간은 각 버전마다 13개월이다. 
- 일반적인 목적을 가진 RPM 기반의 소프트웨어가 결합된 운영체제이다.

7. CentOS
- 업스트림 소스인 레드햇 엔터프라이즈 리눅스와 완벽하게 호환되는 무료 기업용 컴퓨팅 운영체제이다.
- 자체 커뮤니티에 의해 관리되고 있다.

8. 수세 : 독일에서 출시된 배포판으로 유럽에서 인기를 누리고 있으며, 풍부한 기능과 안정성, 보안 기능을 포함하고 있다. 정기적인 배포판이 존재한다기보다는, 언제든지 새로운 버전이 출시되면 업데이트가 가능한 롤링 릴리즈 방식을 사용한다.


### 리눅스의 역사

```
1969년: 켄 톰슨이 초기 형태의 UNIX를 개발(어셈블리 언어)

1971년 : 데니스 리치가 C언어를 개발함으로써, 어셈블리 언어로 되어 있던 UNIX가 C언어로 재작성

1980년대 초중반 : 리처드 스톨먼이 소스를 공개하지 못하도록 하는 분위기와 기술을 상업화하려는 조류에 대한 반감으로 GNU(GNU is Not Unix) 프로젝트 시작, 1985년 FSF(Free Software Foundation)이라는 비영리 재단 단체 설립 후 'GNU선언문' 발표

1987년 : 엔드루 타넨바움은 자유/오픈 소스 소프트웨어로 교육용 유닉스 계열 운영체제인, 미닉스(MINIX)를 개발

1990년대 초중반 : 핀란드 헬싱키 대학의 리누스 토발즈가 미닉스의 커널 소스를 고쳐 GNU 시스템에 적합한 커널을 개발, 스톨먼과 FSF에서 GNU 시스템의 커널로 리눅스를 채택

1994년 : 리눅스 커널 버전 1.0 발표

1996년 : 리눅스 커널 버전 2.0 발표
```

### 리눅스 라이선스

```
GPL : FSF(Free Software Foundation)에서 만든 Free 소프트웨어 라이선스로 내부적 목적 사용시 소스코드 공개 안 해도 되지만, 어떤 형태(유료 or 무료)로든 외부에 공표.배포할 때에는 전체 소스코드를 공개해야함.

LGPL : GPL 완화 버전으로 LGPL이 적용된 라이브러리를 이용하여 개발 시 프로그램 소스코드 공개 안 해도 된다. LGPL 코드를 단순히 이용하는 것이 아니라 이를 수정한 또는 이로부터 파생된 라이브러리를 개발하여 배포하는 경우에는 전체 코드를 공개해야 한다.

BSD 라이선스 : 소스코드 공개 의무 X, 상용(상업적) 소프트웨어에서도 무제한 사용 가능한 라이선스이다.
- 해당 소프트웨어 아무나 개작 가능, 수정한 것 제한 없이 배포 가능
- 수정본의 재배포는 의무 사항 X, 상용 소프트웨어에서도 사용 가능

아파치(Apache) 라이선스 : 아파치 2.0 라이선스는 누구나 해당 소프트웨어에서 파생된 프로그램을 제작할 수 있으며, 저작권을 양도, 전송할 수 있는 라이선스 규정이다.
- 누구든 자유롭게 아파치 소프트웨어를 다운로드 받아 부분 또는 전체를 개인적 혹은 상업적 목적으로 이용할 수 있다.

MIT 라이선스 : 해당 소프트웨어는 누구나 개작할 수 있고, 수정본의 재배포 시에 소스코드 비공개가 가능하다.

MPL : 수정한 2차 소스코드는 MPL로 공개하고 원저작자에게 수정한 부분에 대해 알려야 하지만, 실행 파일은 독점 라이선스로 배포할 수 있다. 사용한 MPL 소프트웨어와 수정한 MPL 소프트웨어에 대한 공개 의무만 가지며, 별도의 소스코드와 실행 파일은 독점 라이선스를 가질 수 있다.
```

## CHAPTER02. 리눅스의 설치

<hr>

### 기본 설치 및 유형

- CentOS 리눅스 커널 예시 및 설명

```
3. 10 . 17. 1

# 3 : 주 버전
# 10 : 부버전, 짝수면 안정 커널, 홀수면 개발 커널
# 17 : 패치 레벨 : 커널의 해당 버전에 대한 수정이 있을 경우 증가
# 1 : 안전 버전에서만 사용
```

###  파티션

하나의 물리적 디스크를 여러 개의 논리적인 디스크로 분할 하는 것


✔ 파티션 특징

- 파티션마다 독립적인 파일 시스템이 운영되기 때문에 파일점검 시간이 줄어들어 부팅 시간을 단축시킬 수 있다.
- 특정 파티션의 파일 시스템이 손상되더라도 다른 파티션에 영향을 주지 않기 때문에 높은 안정성을 보장한다.
- 필요한 파티션만 포맷할 수 있기 때문에 백업과 업그레이드가 편리하다.
- 파티션은 주 파티션, 확장 파티션, 논리 파티션, 스왑 파티션으로 구분된다.

✔ 디스크와 장치명 예시

```
/dev/hd a 3

# hd : 하드디스크 유형 지정 sd=SCSI(Small Computer System Interface) 또는 USB 방식 디스크, hd=IDE 또는 ATA 방식 디스크

# a : 한 케이블에 묶인 하드디스크의 우선 순위를 정함(첫 번째 하드디스크 a, 두 번째 하드디스크 b), 마스터(master) 또는 슬레이브(slave)로 설정

# 3 : 파티션 번호로 1~4번은 primary 또는 extended, 5번부터 logical 파티션
```

- 다른 예시

```
/dev/fd0 
# 첫 번째 플로피 디스크

/dev/fd1
# 두 번째 플로피 디스크

/dev/sda
# 첫 번째 SCSI 디스크

/dev/sdb
# 두 번째 SCSI 디스크

/dev/scd0 
# 혹은 /dev/sr0
# SCSI CD-ROM

/dev/hda
#  IDE 디스크의 Primary Master

/dev/hdb
# IDE 디스크의 Primary Slave

/dev/hdc
# IDE 디스크의 Secondary Master

/dev/hdd
# IDE 디스크의 Secondary Slave
```

✔ LVM(Logical Volumne Manager) 
- 여러 개의 하드디스크를 합쳐서 사용하는 기술로 한 개의 파일 시스템을 사용한다. 
- 서버를 운영하면서 대용량의 별도 저장 공간이 필요할 때 활용한다.
- 다수의 리스크를 묶어서 사용함으로써 파티션의 크기를 줄이거나 늘릴 수 있다.

✔ RAID(Redundant Array of Independent Disks)

- 여러 개의 물리적 디스크를 하나의 논리적 디스크로 인식하여 작동하게 하는 기술
- 여러 개의 하드디스크에 일부 중복된 데이터를 나눠서 저장하는 기술
- 데이터를 저장하는 다양한 방법이 존재하며 이 방법들을 레벨이라 한다.
- 레벨에 따라 저장 장치의 신뢰성을 높이거나 전체적인 성능을 향상시키는 등 다양한 목적을 만족시킨다.

```
RAID 0 : 연속된 데이터를 여러 디스크에 나눠 저장, 입출력 작업이 모든 디스크에 동시에 진행(저장과 읽기 속도 빠르다 but 하나의 디스크라도 고장나면 전체 시스템 사용 불가)

RAID 1 : 미러링 방식으로 하나의 디스크에 데이터를 저장하면 다른 디스크에 동일한 내용이 백업되어 저장, 결함허용을 제공하지만 공간 효율성은 떨어짐

RAID 2 : 스트라이핑 저장방식으로 기록용 디스크와 데이터 복구용 디스크를 별도로 제공, 디스크의 사용 효율성이 낮음

RAID 3 : 스트라이핑 저장방식, 오류 거물을 위해 패리티 방식을 이용, 데이터 복구는 패리티 저장 디스크에 기록된 정보의 XOR을 계산하여 수행, 대형 레코드가 사용되는 단일 사용자 시스템에 적합

RAID 4 : RAID 3과 유사하나 전용 패리티 디스크 사용, RAID 3은 Byte 단위로 데이터를 저장하는 반면, RAID 4는 Block(섹터) 단위로 저장

**RAID 5 : 스트라이핑 저장 방식, 디스크마다 패리티 정보를 가지고 있어 패리티 디스크의 병목현상을 줄이는 것이 가능해 실무에서 많이 사용, 디스크 섹터 단위로 저장, 쓰기 작업이 많지 않은 다중 사용자 시스템에 적합**

RAID 6 : 기본적으로 RAID 5를 확장한 것, 제 2 패리티를 두는 듀얼 패리티를 사용함으로써 더 나은 무정지성을 갖게 함
```

- 이 외에도 각 레벨의 장점을 합친 RAID 0 + 1, RAID 1 + 0이 있다.

✔ 파티션 분할 예시

```
cd /dev
ls sd*
fdisk sda2
# fdisk : 파티션 테이블을 관리하는 명령어로 리눅스의 디스크 파티션을 생성, 수정, 삭제 할 수 있음

l
# a : 파티션 지정
# l : 파티션 목록 확인
# n : 새로운 파티션 추가
# t : 파티션 종류를 변경
# w : 파티션 정보를 저장
# p : 파티션 정보 확인
# q : 작업을 종료

q
```

###  부트 매니저

✔ 부트로더 

- 부트스트랩 로더의 준말로 컴퓨터를 사용자가 사용할 수 있도록 디스크나 플래시에 저장된 운영체제를 읽어 주기억장치에 적재해주는 프로그램이다.

- 부트로더는 부트 매니저라고도 부르며 하드디스크의 첫 번째 섹터인 MBR(Master Boot Record)에 위치한다. MBR은 부트 매니저 프로그램과 파티션 정보를 저장한다.

- 주 파티션마다 부트 섹터가 할당된다.

- 분할된 주 파티션 들은 자신의 부트 레코드를 MBR에 기록하여 실행된다.

- 한 컴퓨터에 다수의 운영체제가 설치되어 있을 경우, 작업 운영체제를 선택하여 부팅할 수 있게 한다.

- x86 아키텍처에서 많이 사용되는 부트로더는 LILO(LInux LOader)와 GRUB(GRand Unified Bootloader)이다.

- LILO는 리눅스 운영체제에 한정되어 사용되는 반면, GRUB는 리눅스 운영체제 외에도 다른 운영체제에서 사용가능하다.

✔ GRUB

LILO의 단점을 보완하고, LILO에 비해 설정 및 사용이 편리하며, 다른 운영체제와 멀티부팅 할 수 있다.

✔  GRUB 1 vs GRUB 2

- GRUB 1의 경우, 첫 번째 파티션이 0부터 시작, GRUB 2의 경우, 첫 번째 파티션이 1에서 시작

- GRUB 1의 경우 root(hd0, 0,0)으로 파티션 지정, kernel/boot/vmlinuz로 부팅하면서 메모리에 위치하는 리눅스 커널에 전달한 인수 지정

- GRUB 2의 경우, /etc/default/grub과 /etc/grub,d를 통해 grub 환경을 설정

✔ 런레벨

리눅스 부팅시 작동하는 서비스들이 있다. 런레벨에 따라 작동하는 서비스를 조정가능하다. 런레벨은 0에서부터 6까지 총 7가지이다.


런레벨 : 기능
```
0 : 시스템 종료(shutdown), 명령어 halt 또는 init 0과 동일

1 : 단일 사용자 모드

2 : 네트워크가 없는 다중 사용자 모드

3 : 텍스트 모드(CUI)에 의한 다중 사용자 모드

4 : 미사용

5 : 그래픽 모드(GUI)에 의한 다중 사용자 모드

6 : 시스템 재시작(재부팅), 명령어 reboot 또는 init 6과 동일
```

## CHAPTER03. 리눅스의 기본 명령어

<hr>

###  일반 명령어

✔  which 명령어

명령어의 경로를 확인하는 명령어이다

``` 
# 절대 경로를 반환하는 명령어
[root@localhost ~]# pwd
/root

# 명령어 pwd의 위치를 확인한다.
[root@localhost ~]# which pwd
/bin/pwd
```

✔ alias[별명="명령어"]

자주 사용하는 명령어를 특정 문자로 입력해두고 명령어 대신 해당 문자를 사용할 수 있게 하는 명령어 이다.

```
# ls -al | more를 문자 m으로 단축
alias m='ls -al | more '
```

✔ unalias [옵션][단축명령어]

- -a : 설정된 모든 alias 해제

```
unalias m
# 단축어 명령 m을 더 이상 사용하지 않는다.
```

✔ 환경변수 PATH

PATH는 실행 파일들의 디렉터리 위치를 저장해 놓는 환경 변수 이다.

명령어 입력자의 현재 작업 디렉터리와 상관없이 특정 명령어를 입력하면 PATH 변수에 저장되어 있는 경로에서 해당 명령어를 찾아 실행한다.

```
#  root에 설정되어 있는 PATH를 확인한다.
[root@localhost ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
```

기존에 PATH에 새로운 경로를 추가하는 방법에는 명령어 PATH나 홈디렉터리의 .bash_profile에 PATH를 추가한다. 기존 경로와 새 경로는 콜론(:)으로 구분한다.

```
export 변수명=$변수명:변수값
```

✔ 명령어 man

리눅스에서 사용하는 명령어들의 메뉴얼을 제공

```
man [색션][옵션] 명령어
```

- 옵션

```
- a : 찾고자하는 명령어의 검색된 메뉴얼 페이지를 모두 출력

- h : 사용법을 출력

- f : whatis 명령과 동일, 키워드와 동일한 man 페이지만 출력

- k : apropos 명령과 동일, 키워드가 포함된 man 페이지 출력

- w : 찾고자 하는 문자의 메뉴얼 페이지가 있는 위치를 출력
```

- 섹션

```
1 :  일반 명령어 관련 메뉴얼이 들어있는 영역

2 : 시스템 호출 관련 메뉴얼이 들어있는 영역

3 : C 표준 라이브러리 함수 관련 메뉴얼이 들어있는 영역

4 : 장치 드라이버 또는 특수 파일에 대한 정보가 들어있는 영역

5 : 특정 파일들에 대한 정보가 들어있는 영역

6 : 게임과 화면보호기에 대한 정보가 들어있는 영역

7 : 리눅스 파일 표준, 프로토콜, 시그널 목록 정보가 들어있는 영역

8 : 시스템 관리 명령어와 데몬 정보가 들어있는 영역

9 : 커널 관리 정보가 들어있는 영역
```

✔ info

리눅스 명령어의 사용 방법, 옵션 등을 나타낸다.

명령어 man에 비해 제공되는 명령어가 한정적이다.

```
info
```

✔ whatis 명령어

명령어에 대한 기능을 간략히 나타낸다.

자세한 사용법과 설명은 명령어 man이나 info로 확인해야 한다.

```
[root@localhost ~]# whatis ls
ls (1)               - list directory contents
ls (1p)              - list directory contents
```

✔ manpath [명령어]

man 페이지의 위치 경로를 검색하여 표시해주는 명령어이다.

✔ whereis [옵션] 명령어

찾고자 하는 명령어의 실행 파일 절대 경로와 소스코드, 설정 파일 및 메뉴얼 페이지를 찾아 출력하는 명령어이다.

```
whereis [옵션] 명령어
```

- 옵션

```
- b : 바이너리 파일만 찾음

- m : 지정된 메뉴얼 섹션에서만 찾음

- M : 메뉴얼 페이지의 위치를 제한

- u : 특정 파일 제외
```

✔ apropos

맨(man) 페이지 설명에서 지정한 키워드를 포함하고 있는 명령어이다.

whatis 데이터베이스에서 문자열을 포함한 것을 검색한다.

whatis 데이터베이스가 만들어져 있어야 이 명령을 쓸 수 있다.

```
apropos 문자열
```

### 사용자 생성 및 계정 관리

✔ useradd [옵션] 계정명

계정을 생성하는 명령어로 명령어 adduser와 동일한 기능을 갖는다.

계정자의 홈 디렉토리는 '/home/계정명'이다.

생성된 계정 정보는 파일 /etc/passwd, /etc/shadow, /etc/group에 저장된다.

```
useradd [옵션] 계정명
```

- 옵션

```
-s : 사용자의 로그인 기본 셸을 지정

-d : 계정의 홈 디렉토리를 지정

-f : 패스워드가 만기된 후 계정이 영구히 말소될 때까지의 기간 지정

-c : 파일 /etc/passwd에 새로운 사용자 설명을 추가

-G : 계정이 속한 그룹 외에 다른 그룹에 계정 추가
```

```
[root@localhost home]# ls
rwk
[root@localhost home]# useradd linuxMaster
[root@localhost home]# ls
linuxMaster  rwk
[root@localhost home]# su linuxMaster
[linuxMaster@localhost home]$ ls
linuxMaster  rwk
[linuxMaster@localhost home]$ whoami
linuxMaster
```

✔ passwd [옵션] 계정명

생성된 계정자의 패스워드를 입력 및 변경하는 명령어이다.

생성된 계정자의 패스워드는 /etc/shadow 파일 안에 기록된다.

```
[root@localhost home]# ls
linuxMaster  rwk
[root@localhost home]# passwd linuxMaster
Changing password for user linuxMaster.
New password: 
Retype new password: 
passwd: all authentication tokens updated successfully.
[root@localhost home]# su rwk
[rwk@localhost home]$ su linuxMaster
Password: 
[linuxMaster@localhost home]$ 
```

- 옵션

```
-S : 계정 상태 표시(Status), (PS=정상, NP=패스워드가 없음, LK=Lock 상태이거나 NP상태)

-d : 계정 패스워드 삭제(delete)

-l : 계정을 lock 상태로 변경(lock)

-u : 계정의 lock 상태를 해제(unlock)
``` 

✔ su [옵션][사용자][셸변수]

switch user(혹은 substitute user)의 줄임말로, 현재의 사용자 계정에서 로그아웃하지 않고 다른 사용자 계정으로 로그인하여 해당 사용자의 권한을 획득하는 명령어이다.

- 옵션

```
-, -l, --login : 지정한 사용자의 환경변수를 적용하여 로그인

-s : 지정된 셸로 로그인

-c : 셸을 실행하지 않고 주어진 명령어 수행
```

✔ usermod [옵션] 명령어

디렉터리 /home에 위치한 사용자들의 정보를 변경하는 명령어로 사용자의 홈 디렉토리 변경, 그룹 변경, 유효기간 등을 변경한다.

- 옵션

```
-u uid : 새로운 UID를 지정, -o 옵션과 같이 사용하면 강제 설정이 가능

-g : 새로운 GID를 지정, 사용자 그룹을 지정 또는 변경

-G : 새로운 보조그룹 지정, 기존 그룹에 포함되어 있는 상태에서 새로운 그룹에 추가 지정

-d 홈 디렉터리 : 새로운 홈 디렉토리를 지정, -m 옵션과 같이 사용하면 새로 생성이 가능

-s 셸 : 새로운 셸 지정

-c 주석 : 새로운 주석 지정

-l ID : 로그인 ID를 바꾸는 옵션으로 새로운 계정명으로 변경
```

✔ userdel

기존 계정 정보를 삭제하는 명령어이다.

옵션 없이 userdel을 사용하면, 디렉토리 /etc/passwd, /etc/shadow, /etc/group에서 해당 계정 정보가 삭제된다.

```
# 옵션
-r  : 계정명의 /var/spool/mail의 메일 파일과 홈 디렉터리의 내용 모두를 삭제
```

✔ change [옵션] [계정명]

패스워드의 만료 정보를 변경하는 리눅스 명령어이다.

- 옵션

```
-l : 사용자 계정 정보를 출력

-m : 설정 암호 최소 사용 일자

-M : 설정 암호 사용 가능 일자

-E : 암호 만기일 지정

-W : 만기 전 변경 요구 경고 날짜 지정(지정된 날짜에 경고 메시지 출력)
```


### 사용자 조회

✔ users [옵션]

시스템에 로그인한 사용자 정보를 출력하며, --version을 붙일 경우  users 명령어 버전 정보를 출력할 수 있다.

✔ who [옵션]

1. 현재 시스템에 접속해 있는 사용자들을 조회할 수 있는 명령어이다.

2. 사용자 계정명, 터미널 정보, 접속 시간, 접속한 서버 정보 등을 확인 할 수 있다.

3. 관리자 root와 일반 사용자 모두 사용이 가능하다.

4. 명령어 "who am i" 또는 "whoami"는 자신의 정보를 조회 할 수 있다.

- 옵션

```
-b : 마지막 시스템 부팅 시간 출력

-q : 로그인한 사용자와 사용자 수를 모두 출력

-r : 현재 시스템의 실행 레벨을 확인 가능
```

✔ w

현재 접속중인 사용자들의 정보를 나타내는 명령어

✔ id 

사용자 계정의 uid, gid, group을 확인하는 명령어이다.

```
[rwk@localhost home]$ id
uid=1000(rwk) gid=1000(rwk) groups=1000(rwk) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```

✔ groups

사용자 계정이 속한 그룹 목록을 확인하는 명령어이다.

### 디렉토리 및 파일

✔ pwd

현재 작업 중인 디렉터리의 위치를 확인하는 명령어

✔ cd [상대경로][절대경로][설정경로]

change directory의 약자로 디렉토리를 이동할 때 사용되는 명령어로 절대 경로는 시작 위치와 상관없이 경로에 모든 디렉토리를 표시한다.

-  절대 경로의 시작은 /(루트)에서부터 시작한다.
- 상대 경로는 현재 작업 중인 디렉터리를 기준으로 표시하는 경로이다.

- 설정경로

```
~ : 현재 사용자의 홈 디렉토리로 이동

. : 현재 디렉토리

.. : 현재에서 한 단계 상위 디렉토리로 이동

/ : 루트 디렉토리로 이동
```

✔ mkdir

make directory의 약자로 새로운 디렉토리를 생성할 때 사용되는 명령어이다.

- 옵션

```
-m : 디렉토리를 생성할 때 권한을 설정(default : 755)
- p : 상위 경로 생성
-v : 디렉토리 생성 후 생성된 디렉토리의 메시지 출력
```

✔ rmdir 디렉토리명

remove directory의 약자로 디렉토리만 삭제하는 명령어로 디렉토리 안에 파일이 존재하는 경우 삭제되지 않는다.


✔ ls [옵션][경로명]

현재 위치한 디렉토리의 파일 목록들을 나타내는 명령어이다.

- 옵션

```
- a : 히든 파일을 포함한 모든 파일과 디렉토리 표시
- l : 퍼미션, 크기, 사이즈 등의 자세한 정보 표시
- d : 지정된 디렉토리의 정보 출력
- r : 알파벳 역순으로 정보 출력
- R : 하위 경로와 그 안에 있는 파일 표시
```

✔ cp [옵션] 원본 대상

파일 또는 디렉토리 복사 명령어

- 옵션

```
-b : 복사 대상 파일이 이미 존재할 경우를 대비하여 백업 파일을 만듦

-f : 복사 대상이 이미 존재하면 복사 대상 파일을 강제로 비우고 복사

-i : 복사 대상이 이미 존재하면 사용자에게 덮어씌울 것인지 유무 확인

-r : 디렉터리를 복사할 경우 하위 디렉토리와 파일을 모두 복사
```

✔ rm [옵션] 파일명|디렉토리명

파일 또는 디렉토리를 삭제하는 명령어이다.

```
- f : 질의 메시지 없이 강제로 파일이나 디렉토리 삭제
- i : 삭제 시 사용자에게 질의
- r : 삭제 디렉토리가 포함하고 있는 하위 디렉토리를 포함하여 모든 파일 삭제
```

✔ mv [옵션] 원본 대상

파일 또는 디렉토리를 이동하거나 파일명을 변경할 때 사용하는 명령어이다.

- 옵션

```
-b : 대상 파일이 이미 있어 지워지는 것을 대비해 백업 파일 생성
-f : 대상 파일이 이미 있어도 사용자에게 어떻게 처리할지 묻지 않음
-v : 파일이 옮겨지는 과정이 자세히 표시
```

✔ touch [옵션] 파일명

파일 크기가 0바이트인 비 파일을 생성한다.

- 접근 시간 : 애플리케이션이나 서비스가 시스템 호출을 사용해 파일을 읽을 때마다 접근시간이 갱신됨
- 수정 시간 : 파일 내용이 변경될 때 파일 수정 시간이 갱신됨
- 변경 시간 : 파일 내용을 수정했을 때 기록되는 시간으로 변경 불가능한 시간

- 옵션

```
-a : 접근시간(access time)을 변경
-m : 수정시간(modify time)을 변경
-c : 시스템 현재 시간으로 파일 시간 정보를 수정
-t 시간정보 : 특정 파일의 시간 정보 변경
-r 파일1 파일2 : 파일1의 시간 정보를 파일2에 동일하게 적용
```

✔ file [옵션] 파일명

파일의 종류 및 파일의 속성값을 나타내는 명령어이다.

- 옵션

```
-b : 파일명은 출력하지 않고 파일 유형만 표시
-f : 파일 목록에서 저장한 파일들에 대해서만 명령을 실행
-z : 압축된 파일의 내용 출력
-i : MIME 타입 문자로 출력
```

✔ find [경로][옵션][정규표현식][파일명]

현재 디렉토리에서부터 하위 디렉토리까지 주어진 조건의 파일을 찾아 해당 경로를 표시한다.

- 옵션

```
-name : 이름을 기준으로 파일 검색
-user : user의 파일이나 디렉토리 검색
-perm : 지정된 권한의 파일 검색
-type : 파일 유형에 따라 파일 검색
-atime n : n일 이전에 접근한 파일 검색
-exec : 검색된 파일에 수행할 명령어 지정
```

```
[root@localhost local]# pwd
/usr/local
[root@localhost local]# find ./ -name test.txt
./test/test2/test.txt
```

✔ locate [파일명]

파일의 위치를 찾는 명령어이다.

✔ cat [옵션][파일]

파일의 내용을 출력하는 명령어이다.

- 옵션

```
-n : 각 문장 앞에 번호 표시, 비어있는 행 포함
-b : 각 문장 앞에 번호 표시, 비어있는 행 제외
-s : 연속되는 2개 이상의 빈 행을 한 행으로 출력
-A : 텍스트 파일에 존재하는 개행 문자나 탭 문자 등을 확인
```

✔ head [옵션] 파일 명

파일의 앞부분을 지정한 만큼 출력하는 명령어이다.

- 옵션

```
- c : 출력을 원하는 용량 지정
-숫자 또는 -n 숫자 : 출력을 원하는 줄 수 지정, 옵션이나 숫자를 지정하지 않으면 기본적으로 10개씩 출력
```

✔ tail [옵션] 파일 명

파일의 마지막 행을 기준으로 지정한 행까지의 파일 내용 일부를 출력하는 명령어이다.

- 옵션

```
-c : 출력을 원하는 용량 지정
-숫자 또는 -n 숫자 : 출력을 원하는 줄 수 지정, 옵션이나 숫자를 지정하지 않으면 기본적으로 10개씩 출력
-f : 지정된 파일에 새롭게 추가되는 파일 내용을 실시간으로 출력
-v : 파일을 출력할 때 파일명을 표시
-q : 파일을 출력할 때 파일명을 표시하지 않음
```

```
# test.txt 파일 head, tail 예제

[root@localhost test2]# head -4 test.txt
this is test file


this file's type is text file
[root@localhost test2]# tail -4 test.txt
test4


test5
```

✔ more [옵션] 파일명

파일을 확인하는 명령어로 화면 단위로 끊어서 출력하는 명령어이다.

위에서 아래 방향으로만 출력되기 때문에 지나간 내용을 다시 볼 수 없다. 옵션으로는 -숫자를 입력하면 한 페이지에 표시되는 라인 수를 볼 수 있다.


✔ less

텍스트 파일을 한 번에 한 화면씩 나타내는 명령어이다.

기능적으로 more를 확장한 것으로 커서를 파일의 상하좌우로 이동할 수 있다.

✔ grep [옵션] 문자열 파일명

파일에서 특정한 패턴(문자열) 또는 정규표현식으로 나타낸 단어를 찾는 명령어이다.

- 옵션

```
-r : 디렉토리 내의 모든 디렉토리와 파일들을 검색하도록 지정

-E : 패턴을 정규표현식으로 확장

-i : 대문자, 소문자 차이 무시

-v : 라인 수 출력

-n : 라인 수 출력

-l : 문자열이 포함된 파일명 출력
```

```
[root@localhost test2]# grep -r "type" test.txt
this file's type is text file

[root@localhost test2]# grep -n "type" test.txt
4:this file's type is text file
```

✔ wc [옵션] 파일명
  
파일의 라인 수, 단어 수, 알파벳 수를 알려주는 명령어이다.

- 옵션

```
-l : 전체 라인 수 출력
-w : 전체 단어 수 출력
-c : 전체 문자(알파벳) 수 출력
```

```
[root@localhost test2]# wc test.txt
 35  25 146 test.txt
# 35 : 라인수
# 25 : 단어 수
# 146 : 알파벳 수
# test.txt : 파일 이름
```

✔ sort [옵션] 정렬할 파일명

명령어 결과나 문서 내용을 정렬하는 명령어이다.

- 옵션

```
-b: 앞 공백 무시
-o : 저장할 파일 명시
-r : 역순으로 표시
-f : 대소문자 구분하지 않음
-t : 필드 구분자 지정
-u : 중복 행 제거
-m : 정렬 파일 병합
-n : 숫자만 비교
```

✔ cut [옵션] 파일명

파일에서 특정 필드를 추출해 낸다. 필드는 구분자로 구분할 수 있다.

```
-c : 잘라낸 곳의 글자 위치를 지정, 콤마나 하이픈을 사용하여 범위 지정

-f : 잘라낸 필드 지정

-d : 필드를 구분하는 문자 지정, 디폴트는 탭

-s : 대소문자 구분하지 않음
```

✔ split [옵션] 파일명

하나의 파일을 여러 개의 작은 파일로 분리할 때 사용한다.

파일의 내용을 라인 수로 분할할 수도 있고, 용량 단위로 분할 할 수도 있다. 

주로 디스켓에 파일을 나누어 복사하거나 백업할 때 CD-RW 용량 단위로 분할할 경우 유용하다.

- 옵션

```
-b : 파일을 byte 단위로 분할
-l : 파일을 주어진 라인 수 단위로 분할
```

### 파일 비교 명령어

✔ diff [옵션] 파일명1 파일명2 

✔ diff [옵션] 디렉토리1 디렉토리2

두 개의 파일을 행 단위로 비교하여 다른 부분을 출력하는 명령어이다.

두 개의 파일명을 매개변수로 사용하여 화면에 차이점을 나열한다.

- 옵션

```
-b : 연속된 공백 무시
-i : 대소문자를 구분하지 않음
-s : 두 파일이 같은지 확인
-r : 두 디렉토리의 차이점 출력
```

✔ cmp [옵션] 파일명1 파일명2

두 개의 파일을 바이트(문자) 단위로 비교하여 출력하는 명령어이다.

- 옵션

```
-b : 두 파일 간의 다른 바이트를 출력
-l : 두 파일 간의 다른 문자 위치와 문자를 출력
-s : 아무 것도 출력하지 않고 실행 결과 코드만 반환
```

✔ comm [옵션] 파일1 파일2

두 개의 파일을 줄 단위로 비교하여 출력하는 명령어이다.

- 옵션

```
-1 : 파일1에만 있는 내용을 제외하고 내용 출력
-2 : 파일2에만 있는 내용을 제외하고 내용 출력
-3 : 파일1과 파일2에 공통으로 존재하는 내용을 제외하고 출력
```

✔ 리다이렉션

1. 표준 입력과 표준 출력 방향을 재지정하는 것이다.
2. 표준 입력/출력/에러가 화면이 아닌 파일로 대체된다. 즉, 모니터로 출력이 파일로 재지정한다.
3. 표준 입력 장치는 키보드, 표준 출력 장치는 모니터, 표준 에러 장치는 모니터이다.

✔ 리다이렉션 연산자

```
> : 명령을 화면에 출력하는 것이 아니라 프린터나 파일에 출력하도록 전송, 파일이 존재하지 않으면 새로운 파일을 만들고 같은 파일이 존재하면 덮어씀

>> : 파일이 있는 경우 지정된 파일에 결과를 추가, 파일이 존재하지 않으면 지정된 이름으로 파일 생성

< : 키보드가 아닌 지정된 파일에서 입력 내용을 읽어옴

>& : 명령의 출력을 다른 명령의 입력으로 보냄

<& : 명령의 입력을 읽고 다른 명령의 출력으로 보냄
```

✔ 파이프

둘 이상의 명령을 함께 묶어 출력 결과를 다른 프로그램으로 입력으로 전환하는 기능이다.

```
명령어 -> 실행단계 -> 명령어 -> 실행단계 -> 실행 결과
```

현재 명령의 표준 출력을 다음 명령의 표준 입력으로 사용하는 것이다.

명령어와 명령어의 연결은 '|' 기호를 사용한다.

```
명령어1|명령어2|명령어3
```

명령어1의 출력 결과는 명령어2의 입력으로 처리되며 명령어2의 처리 결과는 명령어 3의 입력이 된다.

더 이상 처리할 명령어가 없으면 표준 출력장치인 화면으로 출력한다.

### 네트워크 관련 명령어

✔ ping [옵션] [도메인명 혹은 IP주소]

외부 호스트에 신호를 보내며 신호를 받은 호스트는 응답을 주면서 서로 네트워크가 연결되었음을 확인시켜 주는 명령어이다.

- 옵션

```
-c [요청 수] : ping을 보낼 횟수로 생략할 경우 무제한 으로 실행

-i[초] : 신호를 보내는 시간 간격으로 생략될 경우 1초 단위로 설정

-s [패킷 크기] : 전송하는 패킷 크기를 바이트(byte) 단위로 설정
```

✔ traceroute [도메인명 혹은 IP주소]

 목적지 호스트까지의 경로를 표시하고 그 구간의 정보를 기록하는 명령어이다.

 목적지 호스트까지의 패킷 전송 지역을 측정하거나 목적지 호스트로 향하는 경로상에 어떤 장애가 있는 경우 위치를 파악 할 수 있다.

✔ nslookup [옵션][호스트명]

도메인명으로 IP 주소를 조회하거나 또는 IP 주소로 도메인명을 조회하는 명령어이다. 옵션으로는 -type=레코드를 입력하면, 레코드 타입을 지정할 수 있다.

- DNS 레코드 타입

```
NS : 도메인의 네임서버 정보
MX : 도메인의 MX(Mail Exchange) 서버
A : 호스트의 IP주소
CNAME : 별칭으로 부여된 canonical name(도메인 네임)
SOA : 도메인의 start-of-authority 정보
PRT : IP 주소에 대한 호스트명
```

✔ dig [서버명][호스트명][질의타입]

호스트명에 대한 IP 주소 정보 또는 IP 주소에 대한 호스트명을 조회하는 명령어이다.

- 질의타입

```
a : 도메인 IP 정보
any : 지정된 도메인의 모든 정보
mx : 지정된 도메인의 메일 서버 정보
ns : 네임 서버 정보
soa : SOA 정보
```

✔ host [옵션][도메인 또는 IP주소][DNS서버]

호스트명을 알고 있는데 IP 주소를 모르거나 그 반대의 경우 사용하는 명령어이다.

호스트명을 이용하면 IP 주소 뿐만 아니라 하위 호스트명도 조회할 수 있다.

호스트는 시스템에 등록된 DNS 서버를 이용하여 검색하는데 다른 DNS 서버를 이용 시 따로 지정할 수 있다.

- 옵션

```
-d  : 디버깅 모드로 출력
-l zone : zone 아래 모든 시스템을 출력
-r : 반복 처리 안 함
-t type : type를 지정하여 정보를 얻음
```

✔ hostname

시스템 이름을 확인하거나 변경할 때 사용하는 명령어이다.

- 옵션

```
-a : 별칭 출력
-d : 도메인명 출력
-F : 지정한 파일에서 호스트명을 설정
-v : 호스트 설정이나 호스트명을 자세히 출력
```

### 시스템 종료 명령어

✔ shutdown [옵션] 시간 [경고메시지]

시스템을 종료하거나 재부팅 하는 명령이다.

현재 수행 중인 프로세스를 종료하며 sync를 수행하여 저장되지 않은 데이터를 디스크에 저장하고 모든 파일 시스템을 mount 시킨 후에 시스템을 종료한다.

root 사용자만이 권한을 가지고 있는 명령어이다.

- 옵션

```
-r : 종료 후 재부팅
-h : 시스템 종료
-c : 진행 중인 shutdown 명령 취소
-k : 경고메시지만 출력하고 shutdown을 하지 않음
-f : 재부팅시 fsck 명령을 생략하고 부팅을 빠르게 진행
-n : init을 호출하지 않고 shutdown
-t sec : 지정 시간에 시스템 재시동
```

- shutdown 옵션 예시

```
shutdown -h now : 즉시 종료
shutdown -h +5 :  5분 후 종료
shutdown -r now : 즉시 재부팅
shudown -r 10:00 : 10시에 재부팅
shutdown -h 10:00 : 10시에 종료
```

✔ init 런레벨

shutdown 명령어와 동일한 기능을 가진 명령어이다.

- 런레벨

```
0 : 지금 즉시 종료
1 : 단일 사용자 
2 : 다중 사용자 모드(NFS 사용 불가로 서버와 공유 안 됨)
3 : 텍스트 모드로 재시작
4 : 사용 안 함
5 : X 윈도우 모드로 재시작
6 : 재가동 모드(재부팅)
```

✔ reboot [옵션]

시스템을 재부팅하는 명령어이다. 옵션으로는 -r이 있으며, 시스템 강제 재부팅 명령을 의미한다.

✔ halt [옵션]

시스템을 종료하는 명령어다. 옵션으로 -f가 있으며 시스템을 강제 종료를 의미한다.

### 기타 명령어

✔ cal(calender) [옵션][[month]year] 

시스템에 설정된 달력을 출력하는 명령어이다.

옵션 없이 실행시킬 시 현재 시스템 날짜로 기록된 달(month)을 출력한다.

```
[root@localhost /]# cal 12 2022
    December 2022   
Su Mo Tu We Th Fr Sa
             1  2  3
 4  5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30 31
```

- 옵션

```
-i : 1월 1일부터 날짜수를 계산하여 출력

-y : 올해의 달력을 출력
```

✔ date [옵션][MMDDhhmm][CC][YY][.ss]]

✔ date [옵션][+FORMAT]

시스템의 날짜와 시간을 표시하거나 변경한다.

- 옵션

```
-s : 시간 설정 순서는 'hh:mm:ss'
-y : 올해의 달력을 출력
```

✔ clear

터미널의 내용을 지우는 명령어이다.

✔ tty

현재 사용하고 잇는 단말기 장치의 경로명과 파일명을 나타낸다.

보통 텔넷 등에서 동일한 계정으로 여러 개 로그인한 경우 확인 시 유용하다.


✔ time

프로그램이 수행되는 데 걸리는 시간을 측정하여 출력하는 명령어이다.

명령어 실행 시간을 측정할 수 있으므로 셸 스크립트 작성이나 간단한 성능 체크에 유용하다.

세 가지 시간 결과 real, user, sys를 보여준다. (real은 총 수행시간, user는 CPU가 사용자 영역에서 보낸 시간, sys는 시스템 호출 실행에 걸린 시간이다.)

✔ wall <메시지 내용>

모든 로그인 된 사용자들에게 터미널을 통해 메시지를 전달하는 명령어이다.

✔ write 계정명 [ttyname]

해당 사용자에게 메시지를 전달하는 명령어이다.

✔ mesg [y/n]

write를 사용해서 들어오는 메시지 수신 여부를 확인하고 제어하는 명령어이다.