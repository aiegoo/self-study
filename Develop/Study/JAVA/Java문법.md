## Java 문법

### 연산자 Operator 

<hr>

연산자(operator) : 연산을 수행하는 기호

피연산자(operand) : 연산자의 작업 대상

**✔ 연산자의 우선순위**

1. 산술 > 비교 > 논리 > 대입 : 대입은 제일 마지막에 수행 된다.

2. 단항(1) > 이항(2) > 삼항(3) : 단항 연산자의 우선순위가 이항 연산자보다 높다.

3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행 방향은 왼쪽에서 오른쪽이다.


**✔ 산술 변환**

연산 수행 직전에 발생하는 피연산자의 자동 형변환

1. 두 연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)

2. 피연산자의 타입이 int보다 작으면 int로 변한된다.

**✔ 증감 연산자(단항 연산자)**

증가 연산자 (++) : 피연산자의 값을 1 증가시킨다.

감소 연산자 (--) : 피연산자의 값을 1 감소시킨다.

```
전위형 : 값이 참조되기 전에 증가시킨다.
ex) j = ++i; 
후위형 : 값이 참조된 후에 증가시킨다.
ex) j=i++;
```

**✔ 비트 연산자**

```
| (OR연산자) : 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 그 외에는 0을 얻는다.

& (AND연산자) : 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.

^(XOR연산자) : 피연산자의 값이 서로 다를때만 1을 결과로 얻는다. 같을 때에는 0을 얻는다.
```

**✔ 쉬프트 연산자**


x << n : $x\times2^n$의 결과와 같다.

x >> n : $x/2^n$의 결과와 같다.

**✔ 조건 연산자**

```java 
// 조건식 ? 식1 :식2
// 조건이 참이면 식1, 거짓이면 식2

result = (x>y) ? x : y;
```

### 조건문

<hr>

**✔ if문**

```java
if(조건식){
    // 조건식이 참(true)일 때 수행될 문장들을 적는다.
}
```

**✔ if-else문**

```java
if(조건식){
    // 조건식이 참(true)일 때 수행될 문장들을 적는다.
}else{
    // 조건식이 거짓(false)일 때 수행될 문장들을 적는다.
}
```

**✔ if-else if문**

```java
if(조건식1){
    // 조건식1의 연산결과가 참일 때, 수행될 문장들을 적는다.
}else if(조건식2){
    // 조건식2의 연산결과가 참일 때 수행될 문장들을 적는다.
}else if(조건식3){
    // 조건식3의 연산결과가 참일 때 수행될 문장들을적는다.
}else{
    // 마지막에는 보통 else블럭으로 끝나며, else블럭은 생략가능하다.
    // 위의 어느 조건식도 만족하지 않을 때, 수행될 문장들을 적는다.
}
```

**✔ switch문**

```
1. 조건식을 계산한다.
2. 조건식의 결과와 일치하는 case문으로 이동한다.
3. 이후의 문장들을 수행한다.
4. break문이나 switch문의 끝을 만나면 switch문 전체를 빠져나간다.
```

switch문의 제약조건

```
1. switch문의 조건식 결과는 정수 또는 문자열이어야 한다.
2. case문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다.
```

### 반복문

<hr>

**✔ for문**

```java
for(초기화; 조건식; 증감식){
    수행될 문장
}
// 초기화 -> 조건식 -> true면 수행될 문장 -> 증감식
// -> 조건식 -> true면 수행될 문장 -> 증감식 -> .. 반복
```

**✔ 향상된 for문**

JDK1.5부터 배열과 컬렉션에 저장된 요소에 접근할 때 기존보다 편리한 방법으로 처리할 수 있도록 for문의 새로운 문법이 추가되었다.

```java
for (타입 변수명 : 배열 또는 컬렉션){
    // 반복할 문장
}
```

위의 문장에서 타입은 배열 또는 컬렉션의 요소의 타입이어야 한다. 배열 또는 컬렉션에 저장된 값이 매 반복마다 하나씩 순서대로 읽혀서 변수에 저장된다. 그리고 반복문의 괄호{}내에서는 이 변수를 사용해서 코드를 작성한다.

```java
int[] arr={10,20,30,40,50};
// 기존 for문
for(int i=0; i<arr.length; i++){
    System.out.println(arr[i]);
}

// 향상된 for문
for (int temp : arr){
    System.out.println(temp);
}
```

**✔ 이름 붙은 반복문**

break문은 근접한 단 하나의 반복문만 벗어날 수 있기 때문에, 여러 개의 반복문이 중첩된 경우에는 break문으로 중첩 반복문을 완전히 벗어날 수 없다. 이 때는 중첩 반복문 앞에 이름을 붙이고 break문과 continue문에 이름을 지정해 줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다.


### 예외처리

<hr>

**✔ 프로그램 오류**

```
컴파일 에러 : 컴파일 시에 발생하는 에러
런타임 에러 : 실행 시에 발생하는 에러
논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것
```

**✔ 에러(error) vs 예외(Exception)**

```
에러(error) : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류

예외(Exception) : 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류
```

**✔ Exception 클래스 vs RuntimeException 클래스**

```
Exception 클래스들 : 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외

RuntimeException 클래스들 : 프로그래머의 실수로 발생하는 예외
```

**✔ try-catch문에서의 흐름**

```
try블럭 내에서 예외가 발생한 경우

1. 발생한 예외와 일치하는 catch블럭이 있는지 확인한다.
2. 일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행한다. 만일 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못한다.

try블럭 내에서 예외가 발생하지 않은 경우
1. catch블럭을 거치지 않고, try-catch문을 빠져나가서 수행을 계속한다.
```

**✔ printStackTrace()와 getMessage()**

예외가 발생했을 때, 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨 있으며, getMessage()와 printStackTrace()를 통해서 이 정보들을 얻을 수 있다. catch블럭의 괄호()에 선언된 참조변수를 통해 이 인스턴스에 접근할 수 있다. 이 참조변수는 선언된 catch블럭 내에서만 사용 가능하며, 자주 사용되는 메서드는 다음과 같다.

```
printStackTrace() : 예외발생 당시 호출스탱(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.

getMessage() : 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.
```

**✔ 멀티 catch 블럭**

JDK 1.7부터 catch블럭을 '|'기호를 이용해서, 하나의 catch 블럭으로 합칠 수 있게 되었으며, 이를 '멀티 catch블럭'이라 한다. 

```java
try{

}catch(ExceptionA e){

}catch(ExceptoinB e2){

}


try{

}catch(ExceptionA e| ExceptionB e2){

}
```

**✔ 자동 자원 반환 - try-with-resources문**

try-with-resources문의 괄호() 안에 객체를 생성하는 문장을 넣으면, 이 객체는 따로 close()를 호출하지 않아도 try블럭을 벗어나는 순간 자동적으로 close()가 호출 된다. 그 다음에 catch블럭 또는 finally블럭이 수행된다.
